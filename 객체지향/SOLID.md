# 객체지향 설계 5원칙 SOLID

## SRP(Single Responsibility Principle) 단일 책임 원칙

한 클래스는 하나의 책임만 가져야 한다.

### SRP가 안지켜진 사례

- 변수레벨
    - 하나의 속성이 여러 의미를 갖는 경우
    - 어떤 곳에서는 쓰고, 어떤 곳에선 안쓰는 속성이 있는 경우
- 메소드레벨
    - 분기처리를 위한 if문이 많을 경우

## OCP (Open Closed Principle) 개방 폐쇄 원칙

**자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.**

상위 클래스 또는 인터페이스를 중간에 둠으로써 자신은 변화에 대해서는 폐쇄적이지만, 인터페이스는 외부의 변화에 대해서 확장을 개방해 줄 수 있다.

현실의 예를들면 상점직원이 아무리 바뀐다고해서 손님이 상품을 구매하는 데는 지장이 없다. 이는 직원은 판매 인터페이스를 구현해야하기 때문이다. 손님은 판매 인터페이스와 소통하기 때문에 직원이 누구든 지장이 없다.

이러한 부분은 JDBC와 Mybaris, Hibernate 등 Java에서는 Stream(Input, Out)에서 찾아볼 수 있다,

## LSP (Liskov Subsititution Principle) 리스코프 치환 원칙

**서브 타입은 언제나 자신의 기반(상위) 타입으로 교체 할 수 있어야 한다.**

즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 수행하는 데 문제가 없어야 한다. 이것은 OOP 4대 특성의 상속, 인터페이스 원칙이 잘 지켜진 다면 LSP는 자동으로 잘 적용된 것이다. (주로 조직도, 계층도 관점에서의 상속이 LSP를 위배하는 문제가 생긴다.)

## ISP (Interface Segregation Principle) 인터페이스 분리 원칙

**클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.**

**프로젝트 요구 사항과 설계에 따라서 SRP(단일 책임 원칙) / ISP(인터페이스 분리 원칙)를 선택한다.**

예를들어

```java
class 사람 implements 군인
군인 홍길동 = new 사람()
```

```new 사람()```을 통해 군인 인터페이스의 메소드만을 사용하도록 제한하는 것이다. SRP였다면 class를 나눠야 한다.

## DIP (Dependenct Inversion Principle) 의존 역전 원칙

고차원 모듈은 저차원 모듈에 의존하면 안된다. 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 클래스에 의존하지 말자. 로 요약될 수 있다. 즉, 자신보다 변하기 쉬운 것에 의존하지 말라는 것이다. 해결방법은 OCP와 비슷한데, 구체적인 class가 아닌, 인터페이스에 의존함으로써 DIP를 해결한다.

